package gemini

import (
	"context"
	"encoding/json"
	"fmt"
	"os"

	"github.com/joho/godotenv"
	"google.golang.org/genai"
)

type ModelType string

const (
	Gemini_1_0_Pro        ModelType = "gemini-1.0-pro"
	Gemini_1_0_Pro_001    ModelType = "gemini-1.0-pro-001"
	Gemini_1_5_Pro        ModelType = "gemini-1.5-pro"
	Gemini_1_5_Flash      ModelType = "gemini-1.5-flash"
	Gemini_2_0_Flash      ModelType = "gemini-2.0-flash"
	Gemini_2_0_Flash_Lite ModelType = "gemini-2.0-flash-lite"
	Gemini_2_0_Flash_Exp  ModelType = "gemini-2.0-flash-exp-image-generation"
	Gemini_2_5_Pro        ModelType = "gemini-2.5-pro-exp-03-25"
	Gemini_2_5_Flash      ModelType = "gemini-2.5-flash-preview-04-17"
	LearnLM               ModelType = "learnlm-2.0-flash-experimental"
)

var ModelTypeToName = map[ModelType]string{
	Gemini_1_0_Pro:        "Gemini 1.0 Pro",
	Gemini_1_0_Pro_001:    "Gemini 1.0 Pro 001",
	Gemini_1_5_Pro:        "Gemini 1.5 Pro",
	Gemini_1_5_Flash:      "Gemini 1.5 Flash",
	Gemini_2_0_Flash:      "Gemini 2.0 Flash",
	Gemini_2_0_Flash_Lite: "Gemini 2.0 Flash Lite",
	Gemini_2_0_Flash_Exp:  "Gemini 2.0 Flash Exp",
	Gemini_2_5_Pro:        "Gemini 2.5 Pro",
	Gemini_2_5_Flash:      "Gemini 2.5 Flash",
}

func GetModelTypeName(modelType ModelType) string {
	if name, exists := ModelTypeToName[modelType]; exists {
		return name
	}
	return "Unknown Model Type"
}

type GeminiClient struct {
	client *genai.Client
	ctx    context.Context
}

func NewGeminiClient() (*GeminiClient, error) {
	if err := godotenv.Load(); err != nil {
		return nil, err
	}

	apiKey := os.Getenv("GOOGLE_API_KEY")
	if apiKey == "" {
		return nil, fmt.Errorf("GOOGLE_API_KEY not set in .env file")
	}

	ctx := context.Background()

	client, err := genai.NewClient(ctx, &genai.ClientConfig{
		APIKey:  apiKey,
		Backend: genai.BackendGeminiAPI,
	})

	if err != nil {
		return nil, err
	}
	return &GeminiClient{client: client, ctx: ctx}, nil
}

func (g *GeminiClient) GenerateObject(mdl string, prompt string, system string, isMaster bool) (map[string]interface{}, error) {

	var reqs = []string{"type", "query"}
	if !isMaster {
		reqs = append(reqs, "response")
	} else {
		reqs = append(reqs, "agents")
	}

	model, err := g.client.Models.GenerateContent(g.ctx, mdl, genai.Text(prompt),
		&genai.GenerateContentConfig{
			SystemInstruction: &genai.Content{Parts: []*genai.Part{{Text: system}}},
			ResponseMIMEType:  "application/json",
			ResponseSchema: &genai.Schema{
				Type: genai.TypeObject,
				Properties: map[string]*genai.Schema{
					"type": {
						Type:        genai.TypeString,
						Description: "Agent Name",
					},
					"query": {
						Type:        genai.TypeString,
						Description: "String",
					},
					"response": {
						Type:        genai.TypeString,
						Description: "string",
					},
					"agents": {
						Type:        genai.TypeArray,
						Description: "Array of agent objects if more agents required to specialize the job",
						Items: &genai.Schema{
							Type: genai.TypeObject,
							Properties: map[string]*genai.Schema{
								"type": {
									Type:        genai.TypeString,
									Description: "agent name",
								},
								"usecase": {
									Type:        genai.TypeString,
									Description: "specific use case for the agent",
								},
								"system": {
									Type:        genai.TypeString,
									Description: "the agent prompt generated by the agent",
								},
								"prompt": {
									Type:        genai.TypeString,
									Description: "fine tuned prompt to finish the work",
								},
								"model": {
									Type:        genai.TypeString,
									Description: "gemini model name",
								},
							},
							Required: []string{"type", "usecase", "system", "prompt", "model"},
						},
					},
				},
				Required: reqs,
			},
		})

	if err != nil {
		return nil, err
	}

	jsonData := model.Candidates[0].Content.Parts[0].Text

	var result map[string]interface{}

	err = json.Unmarshal([]byte(jsonData), &result)
	if err != nil {
		return nil, err
	}

	return result, nil
}
